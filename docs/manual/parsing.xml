<chapter id="parsing"><title>Parsing XML</title>
    <!--=================================================================================-->
    <section id="parsing-intro"><title>Introduction</title>
	<para>
	    There are two different ways to parse XML data using xmlwrapp. They are similar to the standard Document Object Model
	    (DOM) and the Simple API for XML (SAX), although not exact. The two parsing methods differ from the two main stream
	    parsing models in order to better fit modern C++ programming style.
	</para>

	<para>
	    Which parsing method you choose is entirely left up to you. I won't recommend one over the other because it can quickly
	    become a religious issue. You should pick the method that best fits your style and the project you are going to use
	    xmlwrapp with.
	</para>
    </section>
    <!--=================================================================================-->
    <section id="parsing-tree"><title>Parsing into a Node Tree</title>
	<para>
	    Having xmlwrapp parse an XML document and generate a node tree is the easiest way to work with the XML data. Using the
	    <classname>xml::tree_parser</classname> class, you can parse a file, URL or the contents of memory, into a node tree.
	</para>

	<para>
	    Once xmlwrapp has created a node tree, you can use the API for the objects that make up the tree. This will be one
	    <classname>xml::document</classname> object and possibly many <classname>xml::node</classname> objects.
	</para>

	<example id="parsing-tree-ex"><title>Using the xml::tree_parser Class</title>
	    <screen>
<![CDATA[
#include <xmlwrapp/init.h>
#include <xmlwrapp/tree_parser.h>
#include <xmlwrapp/document.h>

int main (void) {
    xml::init xmlinit;

    xml::tree_parser parser("somefile.xml");
    
    xml::document &doc = parser.get_document();

    return 0;
}
]]>
	    </screen>
	</example>

	<para>
	    You should notice in the above example that the <function>xml::tree_parser::get_document</function> member function
	    returns a reference to a <classname>xml::document</classname> object. You should take care to use this reference and
	    not make a copy of the <classname>xml::document</classname> object. That is of course, unless you actually wanted to
	    make a copy, which is valid and safe, although not very efficient.
	</para>

	<para>
	    The above example does not contain any error condition checking. By default, if there are any errors while parsing the
	    XML document, the <classname>xml::tree_parser</classname> class will throw an exception (a
	    <classname>std::runtime_error</classname> to be exact).
	</para>

	<para>
	    If you don't want the <classname>xml::tree_parser</classname> to throw an exception, you can pass a
	    <constant>bool</constant> to the constructors to disable them. In this case, you will have to check to state of the
	    parser after the constructor returns. This is done with the <function>xml::tree_parser::operator!</function> member
	    function.
	</para>

	<example id="paring-tree-noexception-ex"><title>Using xml::tree_parser Without Exceptions</title>
	    <screen>
<![CDATA[
#include <xmlwrapp/init.h>
#include <xmlwrapp/tree_parser.h>

int main (void) {
    xml::init xmlinit;

    xml::tree_parser parser("somefile.xml", false);

    if (!parser) {
        // ERROR PARSING FILE
        return 1;
    }

    return 0;
}
]]>
	    </screen>
	</example>

	<para>
	    As you can see, using the <classname>xml::tree_parser</classname> class is very easy. At this point, you may be
	    wondering how you work with this node tree. The following chapters should answer your questions. They describe how to
	    work with the <classname>xml::document</classname>, <classname>xml::node</classname> and
	    <classname>xml::attributes</classname> objects.
	</para>
    </section>
    <!--=================================================================================-->
    <section id="pasing-event"><title>Event Based Parsing</title>
	<!--=================================================================================-->
	<para>
	    Event parsing is done using callbacks. In xmlwrapp, these callbacks turn out to be protected virtual member functions
	    that you will override. Events, such as the parser encountering an opening element, will trigger a call to the
	    corresponding member function of your class.
	</para>
	<!--=================================================================================-->
	<section id="parser-event-events"><title>Events</title>
	    <para>
		In order to receive these events, you will need to derive a class from the xmlwrapp
		<classname>xml::event_parser</classname> class. You should then override the appropriate member functions. The
		following table lists a description of each event and the member function you should override to receive that
		event.
	    </para>

	    <table><title>XML Parsing Events</title>
		<tgroup cols="4">
		    <thead>
			<row>
			    <entry align="center">Event</entry>
			    <entry align="center">Description</entry>
			    <entry align="center">Member Function</entry>
			    <entry align="center">Use Requirement</entry>
			</row>
		    </thead>

		    <tbody>
			<row>
			    <entry>Start Element</entry>
			    <entry>An opening tag has been parsed.</entry>
			    <entry><function>start_event</function></entry>
			    <entry>Mandatory (pure virtual).</entry>
			</row>

			<row>
			    <entry>End Element</entry>
			    <entry>A closing tag has been parsed.</entry>
			    <entry><function>end_element</function></entry>
			    <entry>Mandatory (pure virtual).</entry>
			</row>

			<row>
			    <entry>Text</entry>
			    <entry>A text node has been parsed.</entry>
			    <entry><function>text</function></entry>
			    <entry>Mandatory (pure virtual).</entry>
			</row>

			<row>
			    <entry>CDATA</entry>
			    <entry>A CDATA section has been parsed.</entry>
			    <entry><function>cdata</function></entry>
			    <entry>Optional. The default implementation calls the <function>text</function> member function.</entry>
			</row>

			<row>
			    <entry>Processing Instruction</entry>
			    <entry>A processing instruction has been parsed.</entry>
			    <entry><function>processing_instruction</function></entry>
			    <entry>Optional. The default implementation ignores processing instructions.</entry>
			</row>

			<row>
			    <entry>Comment</entry>
			    <entry>An XML comment has been parsed.</entry>
			    <entry><function>comment</function></entry>
			    <entry>Optional. The default implementation ignores comments.</entry>
			</row>

			<row>
			    <entry>Warning</entry>
			    <entry>The XML parser found a non-fatal error in the XML document.</entry>
			    <entry><function>warning</function></entry>
			    <entry>Optional. The default implementation ignores warnings.</entry>
			</row>
		    </tbody>
		</tgroup>
	    </table>

	    <para>
		With all of these member functions, you should return <constant>true</constant> if you want the XML parser to
		continue. If you return <constant>false</constant>, or throw an exception, the XML parser will stop parsing the
		current document.
	    </para>

	    <para>
		For a good example of event parsing, see the <filename>02-event_parsing</filename> example in the
		<filename>examples</filename> directory.
	    </para>
	</section>
	<!--=================================================================================-->
	<section id="parsing-event-use"><title>Using the Derived Class to Parse an XML Document</title>
	    <para>
		Once you have created a class that is derived from <classname>xml::event_parser</classname> and have overridden the
		necessary member functions, you are ready to parse XML documents with it. The
		<classname>xml::event_parser</classname> provides a few different ways of parsing XML documents.
	    </para>

	    <para>
		The easiest way is to use the <function>parse_file</function> member function. It takes the name of a file or a
		URL and will parse the entire file before returning. You may also choose the similar function,
		<function>parse_stream</function> that will parse XML data coming from a <classname>std::istream</classname>
		object such as <classname>std::cin</classname>.
	    </para>

	    <para>
		You also have the option of feeding the parser XML data piece by piece. You begin by calling
		<function>parse_chunk</function> with the current piece of XML data. You continue calling that function until you
		have no more XML data to parse. You should then call the <function>parse_finish</function> member function to tell
		the parser that there is no more XML data to parse. This method can be very useful, for example, if you are
		reading XML data from a network connection.
	    </para>

	    <example id="parsing-event-ex"><title>Event Parsing Example</title>
		<para>
		    This is a very simple example to give you an idea of what event parsing is comprised of.
		</para>

		<screen>
<![CDATA[
#include <xmlwrapp/init.h>
#include <xmlwrapp/event_parser.h>
#include <string>

class MyEventParser : public xml::event_parser {
private:
    bool start_element (const std::string &name, const attrs_type &attrs) {

        ...

        return true;
    }

    ...

};

int main (void) {
    xml::init xmlinit;

    MyEventParser parser;

    parser.parse_file("somefile.xml");

    return 0;
}
]]>
		</screen>
	    </example>
	</section>
	<!--=================================================================================-->
	<section id="parsing-event-wellformed"><title>Parse Status and Well Formed XML Documents</title>
	    <para>
		Each of the member functions used to make <classname>xml::event_parser</classname> parse XML data, return a
		<constant>bool</constant>. If they return <constant>true</constant>, the parsed XML document was well formed. The
		one exception is the <function>parse_chunk</function> member function. Its <constant>bool</constant> indicates the
		success of parsing the current chunk and <function>parse_finish</function> returns the final parsing status.
	    </para>

	    <para>
		If any of the parsing callbacks (event handling member functions) returned <constant>false</constant>, or threw an
		exception, the final parsing status will be <constant>false</constant>. The final parsing status will also be
		<constant>false</constant> if the XML document was not well formed.
	    </para>

	    <para>
		In the case where the final parsing status is <constant>false</constant>, you can use the
		<function>get_error_message</function> member function to get an error message that should explain why the status
		was <constant>false</constant>. The callback member functions should use the
		<function>set_error_message</function> member function to set the error message when they are going to return
		false or throw an exception.
	    </para>

	    <note>
		<para>
		    Because the callback member functions are really being called from the libxml2 library, exceptions that get
		    thrown from them will not propagate up the calling stack. Instead, they will be trapped (using a
		    <constant>catch (...)</constant> statement) and used to set the parsing state to <constant>false</constant>.
		</para>

		<para>
		    The reason they must be trapped is because C++ exceptions cannot propagate through the libxml2 library, which
		    is written in C. There are some ways around this, but none of them are portable.
		</para>
	    </note>
	</section>
	<!--=================================================================================-->
    </section>
    <!--=================================================================================-->
</chapter>
<!--
    vim:ft=docbk:tw=130
-->
