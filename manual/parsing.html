<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xmlwrapp: Parsing XML</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xmlwrapp
   </div>
   <div id="projectbrief">Lightweight C++ XML parsing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">index</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Parsing XML </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="parsing_intro"></a>
Introduction</h1>
<p>There are two different ways to parse XML data using xmlwrapp. They are similar to the standard Document Object Model (DOM) and the Simple API for XML (SAX), although not exact. The two parsing methods differ from the two main stream parsing models in order to better fit modern C++ programming style.</p>
<p>Which parsing method you choose is entirely left up to you. I won't recommend one over the other because it can quickly become a religious issue. You should pick the method that best fits your style and the project you are going to use xmlwrapp with.</p>
<h1><a class="anchor" id="parsing_tree"></a>
Parsing into a Node Tree</h1>
<p>Having xmlwrapp parse an XML document and generate a node tree is the easiest way to work with the XML data. Using the <a class="el" href="classxml_1_1tree__parser.html" title="The xml::tree_parser class is used to parse an XML document and generate a tree like structure of xml...">xml::tree_parser</a> class, you can parse a file, URL or the contents of memory, into a node tree.</p>
<p>Once xmlwrapp has created a node tree, you can use the API for the objects that make up the tree. This will be one <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> object and possibly many <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> objects.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tree__parser_8h.html">xmlwrapp/tree_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="document_8h.html">xmlwrapp/document.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="classxml_1_1tree__parser.html">xml::tree_parser</a> parser(<span class="stringliteral">&quot;somefile.xml&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classxml_1_1document.html">xml::document</a> &amp;doc = parser.get_document();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>You should notice in the above example that the <a class="el" href="classxml_1_1tree__parser.html#ad6b43bd4645523258a681d60a0675262" title="Get a reference to the xml::document that was generated during the XML parsing. ">xml::tree_parser::get_document()</a> member function returns a reference to a <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> object. You should take care to use this reference and not make a copy of the <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a> object. That is of course, unless you actually wanted to make a copy, which is valid and safe, although not very efficient.</p>
<p>The above example does not contain any error condition checking. By default, if there are any errors while parsing the XML document, the <a class="el" href="classxml_1_1tree__parser.html" title="The xml::tree_parser class is used to parse an XML document and generate a tree like structure of xml...">xml::tree_parser</a> class will throw an exception (a std::runtime_error to be exact).</p>
<p>If you don't want the <a class="el" href="classxml_1_1tree__parser.html" title="The xml::tree_parser class is used to parse an XML document and generate a tree like structure of xml...">xml::tree_parser</a> to throw an exception, you can pass a bool to the constructors to disable them. In this case, you will have to check to state of the parser after the constructor returns. This is done with the <a class="el" href="classxml_1_1tree__parser.html#abde1c0ad1a69a87baca1516ea796b84f" title="Check to see if a xml::tree_parser class is valid. ">xml::tree_parser::operator!</a> member function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tree__parser_8h.html">xmlwrapp/tree_parser.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="classxml_1_1init.html">xml::init</a> xmlinit;</div><div class="line"></div><div class="line">    <a class="code" href="classxml_1_1tree__parser.html">xml::tree_parser</a> parser(<span class="stringliteral">&quot;somefile.xml&quot;</span>, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!parser)</div><div class="line">    {</div><div class="line">        <span class="comment">// ERROR PARSING FILE</span></div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>As you can see, using the <a class="el" href="classxml_1_1tree__parser.html" title="The xml::tree_parser class is used to parse an XML document and generate a tree like structure of xml...">xml::tree_parser</a> class is very easy. At this point, you may be wondering how you work with this node tree. The following chapters should answer your questions. They describe how to work with the <a class="el" href="classxml_1_1document.html" title="The xml::document class is used to hold the XML tree and various bits of information about it...">xml::document</a>, <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node. ">xml::node</a> and <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node. ">xml::attributes</a> objects.</p>
<h1><a class="anchor" id="parsing_event"></a>
Event Based Parsing</h1>
<p>Event parsing is done using callbacks. In xmlwrapp, these callbacks turn out to be protected virtual member functions that you will override. Events, such as the parser encountering an opening element, will trigger a call to the corresponding member function of your class.</p>
<h2><a class="anchor" id="parsing_event_events"></a>
Events</h2>
<p>In order to receive these events, you will need to derive a class from the xmlwrapp <a class="el" href="classxml_1_1event__parser.html" title="The xml::event_parser is used to parse an XML document by calling member functions when certain thing...">xml::event_parser</a> class. You should then override the appropriate member functions. The following table lists a description of each event and the member function you should override to receive that event.</p>
<table class="doxtable">
<tr>
<th>event </th><th>description </th><th>member function </th><th>use requirement  </th></tr>
<tr>
<td>start element </td><td>An opening tag has been parsed. </td><td><a class="el" href="classxml_1_1event__parser.html#aa9f66fa17bb48fa37dcb66e4185c91d0" title="Override this member function to receive the start_element message. ">xml::event_parser::start_element()</a> </td><td>mandatory (pure virtual)  </td></tr>
<tr>
<td>end element </td><td>A closing tag has been parsed. </td><td><a class="el" href="classxml_1_1event__parser.html#aa7b0d5be67685f995e02611c50fcf478" title="Override this member function to receive the end_element message. ">xml::event_parser::end_element()</a> </td><td>mandatory (pure virtual)  </td></tr>
<tr>
<td>text </td><td>A text node has been parsed. </td><td><a class="el" href="classxml_1_1event__parser.html#a6a5feb76a4e6074a122a23c1461c7e5d" title="Override this member function to receive the text message. ">xml::event_parser::text()</a> </td><td>mandatory (pure virtual)  </td></tr>
<tr>
<td>CDATA </td><td>A CDATA section has been parsed. </td><td><a class="el" href="classxml_1_1event__parser.html#a4ba25a715271d0e1a2224c20320b3dac" title="Override this member function to receive the cdata message. ">xml::event_parser::cdata()</a> </td><td>optional; the default implementation calls <a class="el" href="classxml_1_1event__parser.html#a6a5feb76a4e6074a122a23c1461c7e5d" title="Override this member function to receive the text message. ">xml::event_parser::text()</a>  </td></tr>
<tr>
<td>processing instruction </td><td>A processing instruction has been parsed. </td><td><a class="el" href="classxml_1_1event__parser.html#a54a047553e8d5d66acb98cdb7e483b53" title="Override this member function to receive the processing_instruction message. ">xml::event_parser::processing_instruction()</a> </td><td>optional; the default implementation ignores processing instructions  </td></tr>
<tr>
<td>comment </td><td>An XML comment has been parsed. </td><td><a class="el" href="classxml_1_1event__parser.html#a8cd4455aa2fa093367ec0a9aae513ff5" title="Override this member function to receive the comment message. ">xml::event_parser::comment()</a> </td><td>optional; the default implementation ignores comments  </td></tr>
<tr>
<td>warning </td><td>The XML parser found a non-fatal error in the XML document. </td><td><a class="el" href="classxml_1_1event__parser.html#ae0fb379e1ce868ccca5f472621e58ac5" title="Override this member function to receive parser warnings. ">xml::event_parser::warning()</a> </td><td>optional; the default implementation ignores warnings  </td></tr>
</table>
<p>With all of these member functions, you should return <code>true</code> if you want the XML parser to continue. If you return <code>false</code>, or throw an exception, the XML parser will stop parsing the current document.</p>
<p>For a good example of event parsing, see the <code>02-event_parsing</code> example in the <code>examples</code> directory.</p>
<h2><a class="anchor" id="parsing_event_use"></a>
Using the Derived Class to Parse an XML Document</h2>
<p>Once you have created a class that is derived from <a class="el" href="classxml_1_1event__parser.html" title="The xml::event_parser is used to parse an XML document by calling member functions when certain thing...">xml::event_parser</a> and have overridden the necessary member functions, you are ready to parse XML documents with it. The <a class="el" href="classxml_1_1event__parser.html" title="The xml::event_parser is used to parse an XML document by calling member functions when certain thing...">xml::event_parser</a> provides a few different ways of parsing XML documents.</p>
<p>The easiest way is to use the <a class="el" href="classxml_1_1event__parser.html#aceba002b5736704e8bf4286a3d141e42" title="Call this member function to parse the given file. ">xml::event_parser::parse_file()</a> member function. It takes the name of a file or a URL and will parse the entire file before returning. You may also choose the similar function, <a class="el" href="classxml_1_1event__parser.html#a5971297efe8b4ea326c030edcd47b229" title="Parse what ever data that can be read from the given stream. ">xml::event_parser::parse_stream()</a> that will parse XML data coming from a std::istream object such as std::cin.</p>
<p>You also have the option of feeding the parser XML data piece by piece. You begin by calling <a class="el" href="classxml_1_1event__parser.html#a2203324311bc7133caceb5ebff587a7d" title="Call this function to parse a chunk of xml data. ">xml::event_parser::parse_chunk()</a> with the current piece of XML data. You continue calling that function until you have no more XML data to parse. You should then call the <a class="el" href="classxml_1_1event__parser.html#a6d2b4cfc6a212a091b1b277d75f6e57a" title="Finish parsing chunked data. ">xml::event_parser::parse_finish()</a> member function to tell the parser that there is no more XML data to parse. This method can be very useful, for example, if you are reading XML data from a network connection.</p>
<p>This is a very simple example to give you an idea of what event parsing comprises of: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="event__parser_8h.html">xmlwrapp/event_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyEventParser : <span class="keyword">public</span> <a class="code" href="classxml_1_1event__parser.html">xml::event_parser</a></div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classxml_1_1event__parser.html#aa9f66fa17bb48fa37dcb66e4185c91d0">start_element</a> (<span class="keyword">const</span> std::string &amp;name, <span class="keyword">const</span> attrs_type &amp;attrs)</div><div class="line">    {</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    MyEventParser parser;</div><div class="line"></div><div class="line">    parser.parse_file(<span class="stringliteral">&quot;somefile.xml&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="parsing_event_wellformed"></a>
Parse Status and Well Formed XML Documents</h2>
<p>Each of the member functions used to make <a class="el" href="classxml_1_1event__parser.html" title="The xml::event_parser is used to parse an XML document by calling member functions when certain thing...">xml::event_parser</a> parse XML data, return a bool. If they return <code>true</code>, the parsed XML document was well formed. The one exception is the <a class="el" href="classxml_1_1event__parser.html#a2203324311bc7133caceb5ebff587a7d" title="Call this function to parse a chunk of xml data. ">xml::event_parser::parse_chunk()</a> member function. Its bool indicates the success of parsing the current chunk and <a class="el" href="classxml_1_1event__parser.html#a6d2b4cfc6a212a091b1b277d75f6e57a" title="Finish parsing chunked data. ">xml::event_parser::parse_finish()</a> returns the final parsing status.</p>
<p>If any of the parsing callbacks (event handling member functions) returned <code>false</code>, or threw an exception, the final parsing status will be <code>false</code>. The final parsing status will also be <code>false</code> if the XML document was not well formed.</p>
<p>In the case where the final parsing status is <code>false</code>, you can use the xml::event::parser::get_error_message() member function to get an error message that should explain why the status was <code>false</code>. The callback member functions should use the <a class="el" href="classxml_1_1event__parser.html#a0f951b5a8f80068e398ff0e9ad102dfa" title="Set the error message that will be returned from the get_error_message() member function. ">xml::event_parser::set_error_message()</a> member function to set the error message when they are going to return false or throw an exception.</p>
<dl class="section note"><dt>Note</dt><dd>Because the callback member functions are really being called from the libxml2 library, exceptions that get thrown from them will not propagate up the calling stack. Instead, they will be trapped (using a catch (...) statement) and used to set the parsing state to <code>false</code>. The reason they must be trapped is because C++ exceptions cannot propagate through the libxml2 library, which is written in C. There are some ways around this, but none of them are portable. </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 8 2018 17:13:50 for xmlwrapp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
