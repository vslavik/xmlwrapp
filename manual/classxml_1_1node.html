<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xmlwrapp: xml::node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">xmlwrapp
   </div>
   <div id="projectbrief">Lightweight C++ XML parsing library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexml.html">xml</a></li><li class="navelem"><a class="el" href="classxml_1_1node.html">node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxml_1_1node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">xml::node Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> class is used to hold information about one XML node.  
 <a href="classxml_1_1node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_8h_source.html">node.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1cdata.html">cdata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> of type_cdata.  <a href="structxml_1_1node_1_1cdata.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1comment.html">comment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> of type_comment.  <a href="structxml_1_1node_1_1comment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">xml::node::const_iterator</a> provides a way to access children nodes similar to a standard C++ container.  <a href="classxml_1_1node_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classxml_1_1node_1_1iterator.html" title="The xml::node::iterator provides a way to access children nodes similar to a standard C++ container.">xml::node::iterator</a> provides a way to access children nodes similar to a standard C++ container.  <a href="classxml_1_1node_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1pi.html">pi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> of type_pi.  <a href="structxml_1_1node_1_1pi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxml_1_1node_1_1text.html">text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for creating a <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> of type_text.  <a href="structxml_1_1node_1_1text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a940647610d4ab69275a4889886b3cc73" id="r_a940647610d4ab69275a4889886b3cc73"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">node_type</a> { <br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442">type_element</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73ad3894a3c892717b03c8835774bade863">type_text</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73ad08a3d7542cb53715b7eb9fe61afc43a">type_cdata</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73af9787bf54e2a8186b643aaabf94850ad">type_pi</a>
, <br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73aba376b6f894af123d9b0d2d3e9a87754">type_comment</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73aeaad8ffd4e23a12dc244b10502c3630a">type_entity</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73af09519f20be672ab7271f9588cb1f141">type_entity_ref</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a47e2014a31a4e8d5ce5b65610be5785a">type_xinclude</a>
, <br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a90fb6fc3b406e9eabc666307a2182505">type_document</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a5ad2575daf153e4c9342098834e800b1">type_document_type</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a510868f4ada4c9e121907f2926253dc9">type_document_frag</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a4b4ec4e4ae3cd25413af91024e3d5c7d">type_notation</a>
, <br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73ad067513260fc3cba8adb7e4046fa522f">type_dtd</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a71a97e98535c1961a23a781758921fec">type_dtd_element</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73affbc2f67724bd953ca2cc4fb5f788668">type_dtd_attribute</a>
, <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73acd5165d4b1015313b836696388511e04">type_dtd_entity</a>
, <br />
&#160;&#160;<a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a22cffeab9645fd51d6341a7e6ef8de91">type_dtd_namespace</a>
<br />
 }</td></tr>
<tr class="memdesc:a940647610d4ab69275a4889886b3cc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum for the different types of XML nodes  <a href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">More...</a><br /></td></tr>
<tr class="separator:a940647610d4ab69275a4889886b3cc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59270c9d507c08b8b4c5df88ac12913" id="r_ae59270c9d507c08b8b4c5df88ac12913"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae59270c9d507c08b8b4c5df88ac12913">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:ae59270c9d507c08b8b4c5df88ac12913"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type  <br /></td></tr>
<tr class="separator:ae59270c9d507c08b8b4c5df88ac12913"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a36262413721060030db06031e6932233" id="r_a36262413721060030db06031e6932233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a36262413721060030db06031e6932233">node</a> ()</td></tr>
<tr class="memdesc:a36262413721060030db06031e6932233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new blank <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>.  <br /></td></tr>
<tr class="separator:a36262413721060030db06031e6932233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e68e8305a47f686b22a2b39f60c5cb" id="r_a53e68e8305a47f686b22a2b39f60c5cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a53e68e8305a47f686b22a2b39f60c5cb">node</a> (const char *name)</td></tr>
<tr class="memdesc:a53e68e8305a47f686b22a2b39f60c5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> and set the name of the node.  <br /></td></tr>
<tr class="separator:a53e68e8305a47f686b22a2b39f60c5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfe3254a9552e9d398053c67bea42de" id="r_a5cfe3254a9552e9d398053c67bea42de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a5cfe3254a9552e9d398053c67bea42de">node</a> (const char *name, const char *content)</td></tr>
<tr class="memdesc:a5cfe3254a9552e9d398053c67bea42de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> given a name and content.  <br /></td></tr>
<tr class="separator:a5cfe3254a9552e9d398053c67bea42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc8f567fa1ec7ced116ed4fc2cd0c4d" id="r_addc8f567fa1ec7ced116ed4fc2cd0c4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#addc8f567fa1ec7ced116ed4fc2cd0c4d">node</a> (<a class="el" href="structxml_1_1node_1_1cdata.html">cdata</a> cdata_info)</td></tr>
<tr class="memdesc:addc8f567fa1ec7ced116ed4fc2cd0c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_cdata.  <br /></td></tr>
<tr class="separator:addc8f567fa1ec7ced116ed4fc2cd0c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cf010b25c9f0ea2415ae99c6610bc" id="r_aac5cf010b25c9f0ea2415ae99c6610bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aac5cf010b25c9f0ea2415ae99c6610bc">node</a> (<a class="el" href="structxml_1_1node_1_1comment.html">comment</a> comment_info)</td></tr>
<tr class="memdesc:aac5cf010b25c9f0ea2415ae99c6610bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_comment.  <br /></td></tr>
<tr class="separator:aac5cf010b25c9f0ea2415ae99c6610bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1a164e7c81012e4a721531c34d6ba5" id="r_aad1a164e7c81012e4a721531c34d6ba5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aad1a164e7c81012e4a721531c34d6ba5">node</a> (<a class="el" href="structxml_1_1node_1_1pi.html">pi</a> pi_info)</td></tr>
<tr class="memdesc:aad1a164e7c81012e4a721531c34d6ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_pi.  <br /></td></tr>
<tr class="separator:aad1a164e7c81012e4a721531c34d6ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2aa7ee2a4fee030e7c9bb0f64db859" id="r_aaf2aa7ee2a4fee030e7c9bb0f64db859"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aaf2aa7ee2a4fee030e7c9bb0f64db859">node</a> (<a class="el" href="structxml_1_1node_1_1text.html">text</a> text_info)</td></tr>
<tr class="memdesc:aaf2aa7ee2a4fee030e7c9bb0f64db859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_text.  <br /></td></tr>
<tr class="separator:aaf2aa7ee2a4fee030e7c9bb0f64db859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a362154201ae3c6aa4213d4c8319e05" id="r_a7a362154201ae3c6aa4213d4c8319e05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a7a362154201ae3c6aa4213d4c8319e05">node</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;other)</td></tr>
<tr class="memdesc:a7a362154201ae3c6aa4213d4c8319e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> by copying another <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>.  <br /></td></tr>
<tr class="separator:a7a362154201ae3c6aa4213d4c8319e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fa69c582c0c5d2fc067644d608bd24" id="r_a38fa69c582c0c5d2fc067644d608bd24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a38fa69c582c0c5d2fc067644d608bd24">operator=</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;other)</td></tr>
<tr class="memdesc:a38fa69c582c0c5d2fc067644d608bd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this node equal to some other node via assignment.  <br /></td></tr>
<tr class="separator:a38fa69c582c0c5d2fc067644d608bd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cfd0d55c969e9407d09b56fe6d4fd9" id="r_ae6cfd0d55c969e9407d09b56fe6d4fd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae6cfd0d55c969e9407d09b56fe6d4fd9">~node</a> ()</td></tr>
<tr class="memdesc:ae6cfd0d55c969e9407d09b56fe6d4fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor.  <br /></td></tr>
<tr class="separator:ae6cfd0d55c969e9407d09b56fe6d4fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d75545214dba0cf6d7efeb5ecfa2bc" id="r_a02d75545214dba0cf6d7efeb5ecfa2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a02d75545214dba0cf6d7efeb5ecfa2bc">set_name</a> (const char *name)</td></tr>
<tr class="memdesc:a02d75545214dba0cf6d7efeb5ecfa2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>.  <br /></td></tr>
<tr class="separator:a02d75545214dba0cf6d7efeb5ecfa2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bd5408b66cd2d7a0d87aae6c03a821" id="r_af0bd5408b66cd2d7a0d87aae6c03a821"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af0bd5408b66cd2d7a0d87aae6c03a821">get_name</a> () const</td></tr>
<tr class="memdesc:af0bd5408b66cd2d7a0d87aae6c03a821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>.  <br /></td></tr>
<tr class="separator:af0bd5408b66cd2d7a0d87aae6c03a821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4625509cfbe6bf475f751d51ff6f10a" id="r_ab4625509cfbe6bf475f751d51ff6f10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a">set_content</a> (const char *content)</td></tr>
<tr class="memdesc:ab4625509cfbe6bf475f751d51ff6f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the content of a node.  <br /></td></tr>
<tr class="separator:ab4625509cfbe6bf475f751d51ff6f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e81da5ef8eed970e974d1945c4d830" id="r_af7e81da5ef8eed970e974d1945c4d830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af7e81da5ef8eed970e974d1945c4d830">set_text_content</a> (const char *content)</td></tr>
<tr class="memdesc:af7e81da5ef8eed970e974d1945c4d830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the content of a node to given text.  <br /></td></tr>
<tr class="separator:af7e81da5ef8eed970e974d1945c4d830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a99a22514f5563704fc2081f0b72d34" id="r_a2a99a22514f5563704fc2081f0b72d34"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a2a99a22514f5563704fc2081f0b72d34">get_content</a> () const</td></tr>
<tr class="memdesc:a2a99a22514f5563704fc2081f0b72d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the content for this text node.  <br /></td></tr>
<tr class="separator:a2a99a22514f5563704fc2081f0b72d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a52b1707c415f5ea488cffca48a03dd" id="r_a6a52b1707c415f5ea488cffca48a03dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">node_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a6a52b1707c415f5ea488cffca48a03dd">get_type</a> () const</td></tr>
<tr class="memdesc:a6a52b1707c415f5ea488cffca48a03dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this node's "type".  <br /></td></tr>
<tr class="separator:a6a52b1707c415f5ea488cffca48a03dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eb6292a54814e9d50283964c80454c" id="r_ab4eb6292a54814e9d50283964c80454c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1attributes.html">xml::attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab4eb6292a54814e9d50283964c80454c">get_attributes</a> ()</td></tr>
<tr class="memdesc:ab4eb6292a54814e9d50283964c80454c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of attributes.  <br /></td></tr>
<tr class="separator:ab4eb6292a54814e9d50283964c80454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3840b65141aad8d17eebc094ee76c03" id="r_ab3840b65141aad8d17eebc094ee76c03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxml_1_1attributes.html">xml::attributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab3840b65141aad8d17eebc094ee76c03">get_attributes</a> () const</td></tr>
<tr class="memdesc:ab3840b65141aad8d17eebc094ee76c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of attributes.  <br /></td></tr>
<tr class="separator:ab3840b65141aad8d17eebc094ee76c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3f8338528b5f55032d91eab5dd1db4" id="r_a9e3f8338528b5f55032d91eab5dd1db4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a9e3f8338528b5f55032d91eab5dd1db4">get_namespace</a> () const</td></tr>
<tr class="memdesc:a9e3f8338528b5f55032d91eab5dd1db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>.  <br /></td></tr>
<tr class="separator:a9e3f8338528b5f55032d91eab5dd1db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab847851d49148c231bd6630ee1b7e9b3" id="r_ab847851d49148c231bd6630ee1b7e9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab847851d49148c231bd6630ee1b7e9b3">set_namespace</a> (const std::string &amp;href)</td></tr>
<tr class="memdesc:ab847851d49148c231bd6630ee1b7e9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> and its children.  <br /></td></tr>
<tr class="separator:ab847851d49148c231bd6630ee1b7e9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ab51a6c1607946e734021399e13da6" id="r_aa7ab51a6c1607946e734021399e13da6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aa7ab51a6c1607946e734021399e13da6">is_text</a> () const</td></tr>
<tr class="memdesc:aa7ab51a6c1607946e734021399e13da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if this node is a text node or something like a text node, CDATA for example.  <br /></td></tr>
<tr class="separator:aa7ab51a6c1607946e734021399e13da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a5f8a31988380cf45fab6eaff3327c" id="r_a78a5f8a31988380cf45fab6eaff3327c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c">push_back</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;child)</td></tr>
<tr class="memdesc:a78a5f8a31988380cf45fab6eaff3327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> to this node.  <br /></td></tr>
<tr class="separator:a78a5f8a31988380cf45fab6eaff3327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0eccee02bde40ac06bcd632cc5ad38" id="r_ade0eccee02bde40ac06bcd632cc5ad38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ade0eccee02bde40ac06bcd632cc5ad38">swap</a> (<a class="el" href="classxml_1_1node.html">node</a> &amp;other)</td></tr>
<tr class="memdesc:ade0eccee02bde40ac06bcd632cc5ad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this node with another one.  <br /></td></tr>
<tr class="separator:ade0eccee02bde40ac06bcd632cc5ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae944b8c4c154a91ad3e539776f05585a" id="r_ae944b8c4c154a91ad3e539776f05585a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ae944b8c4c154a91ad3e539776f05585a">move_under</a> (<a class="el" href="classxml_1_1node.html">node</a> &amp;new_parent)</td></tr>
<tr class="memdesc:ae944b8c4c154a91ad3e539776f05585a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move this node under another parent.  <br /></td></tr>
<tr class="separator:ae944b8c4c154a91ad3e539776f05585a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c837d33ae3431285c899cadb4071561" id="r_a3c837d33ae3431285c899cadb4071561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html#ae59270c9d507c08b8b4c5df88ac12913">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a3c837d33ae3431285c899cadb4071561">size</a> () const</td></tr>
<tr class="memdesc:a3c837d33ae3431285c899cadb4071561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of children this nodes has.  <br /></td></tr>
<tr class="separator:a3c837d33ae3431285c899cadb4071561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dec73910f4edd024421a8949caa7d7" id="r_a50dec73910f4edd024421a8949caa7d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a50dec73910f4edd024421a8949caa7d7">empty</a> () const</td></tr>
<tr class="memdesc:a50dec73910f4edd024421a8949caa7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if this node has any children.  <br /></td></tr>
<tr class="separator:a50dec73910f4edd024421a8949caa7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2858db5fed987227f80ff1c556b0b" id="r_a19f2858db5fed987227f80ff1c556b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a19f2858db5fed987227f80ff1c556b0b">begin</a> ()</td></tr>
<tr class="memdesc:a19f2858db5fed987227f80ff1c556b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points to the beginning of this node's children.  <br /></td></tr>
<tr class="separator:a19f2858db5fed987227f80ff1c556b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd0fff05e288b7b08d52df1c28be17b" id="r_aacd0fff05e288b7b08d52df1c28be17b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aacd0fff05e288b7b08d52df1c28be17b">begin</a> () const</td></tr>
<tr class="memdesc:aacd0fff05e288b7b08d52df1c28be17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the beginning of this node's children.  <br /></td></tr>
<tr class="separator:aacd0fff05e288b7b08d52df1c28be17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d53ce343ec4ef8678d18cf6c0b4552" id="r_a92d53ce343ec4ef8678d18cf6c0b4552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552">end</a> ()</td></tr>
<tr class="memdesc:a92d53ce343ec4ef8678d18cf6c0b4552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points one past the last child for this node.  <br /></td></tr>
<tr class="separator:a92d53ce343ec4ef8678d18cf6c0b4552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ba735bf213ee58dd287c766ef7309" id="r_a9e7ba735bf213ee58dd287c766ef7309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a9e7ba735bf213ee58dd287c766ef7309">end</a> () const</td></tr>
<tr class="memdesc:a9e7ba735bf213ee58dd287c766ef7309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points one past the last child for this node.  <br /></td></tr>
<tr class="separator:a9e7ba735bf213ee58dd287c766ef7309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd609b79b54671575478022b3cd76dca" id="r_abd609b79b54671575478022b3cd76dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#abd609b79b54671575478022b3cd76dca">self</a> ()</td></tr>
<tr class="memdesc:abd609b79b54671575478022b3cd76dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points back at this node.  <br /></td></tr>
<tr class="separator:abd609b79b54671575478022b3cd76dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f5320e1c6a84e13c7f5692f66b2ffd" id="r_a87f5320e1c6a84e13c7f5692f66b2ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a87f5320e1c6a84e13c7f5692f66b2ffd">self</a> () const</td></tr>
<tr class="memdesc:a87f5320e1c6a84e13c7f5692f66b2ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points back at this node.  <br /></td></tr>
<tr class="separator:a87f5320e1c6a84e13c7f5692f66b2ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a56ed0ea190af87784ea4869525ec8" id="r_aa8a56ed0ea190af87784ea4869525ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aa8a56ed0ea190af87784ea4869525ec8">parent</a> ()</td></tr>
<tr class="memdesc:aa8a56ed0ea190af87784ea4869525ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator that points at the parent of this node.  <br /></td></tr>
<tr class="separator:aa8a56ed0ea190af87784ea4869525ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d14bdf1fd828cfa6ca481f2b3afd57" id="r_a28d14bdf1fd828cfa6ca481f2b3afd57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a28d14bdf1fd828cfa6ca481f2b3afd57">parent</a> () const</td></tr>
<tr class="memdesc:a28d14bdf1fd828cfa6ca481f2b3afd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points at the parent of this node.  <br /></td></tr>
<tr class="separator:a28d14bdf1fd828cfa6ca481f2b3afd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0e38e5095f0e682e00ea47d5d90a30" id="r_a9c0e38e5095f0e682e00ea47d5d90a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a9c0e38e5095f0e682e00ea47d5d90a30">find</a> (const char *name)</td></tr>
<tr class="memdesc:a9c0e38e5095f0e682e00ea47d5d90a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node that has the given name.  <br /></td></tr>
<tr class="separator:a9c0e38e5095f0e682e00ea47d5d90a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8925ba89a935a3f120fdb02acd6bb4" id="r_a2f8925ba89a935a3f120fdb02acd6bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a2f8925ba89a935a3f120fdb02acd6bb4">find</a> (const char *name) const</td></tr>
<tr class="memdesc:a2f8925ba89a935a3f120fdb02acd6bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node that has the given name.  <br /></td></tr>
<tr class="separator:a2f8925ba89a935a3f120fdb02acd6bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2bc3080530e7f48812a73907288ac0" id="r_aac2bc3080530e7f48812a73907288ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aac2bc3080530e7f48812a73907288ac0">find</a> (const char *name, const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;start)</td></tr>
<tr class="memdesc:aac2bc3080530e7f48812a73907288ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node, starting with the given iterator, that has the given name.  <br /></td></tr>
<tr class="separator:aac2bc3080530e7f48812a73907288ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc577bd97012580407428e5f90a3b1fd" id="r_afc577bd97012580407428e5f90a3b1fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#afc577bd97012580407428e5f90a3b1fd">find</a> (const char *name, const <a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> &amp;start) const</td></tr>
<tr class="memdesc:afc577bd97012580407428e5f90a3b1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first child node, starting with the given <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a>, that has the given name.  <br /></td></tr>
<tr class="separator:afc577bd97012580407428e5f90a3b1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c038a0f3fa58c3ed8069f8fe7a3a4" id="r_aa04c038a0f3fa58c3ed8069f8fe7a3a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a> ()</td></tr>
<tr class="memdesc:aa04c038a0f3fa58c3ed8069f8fe7a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element.  <br /></td></tr>
<tr class="separator:aa04c038a0f3fa58c3ed8069f8fe7a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49520dd5df3862084a2e4eb27f8e52ca" id="r_a49520dd5df3862084a2e4eb27f8e52ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a49520dd5df3862084a2e4eb27f8e52ca">elements</a> () const</td></tr>
<tr class="memdesc:a49520dd5df3862084a2e4eb27f8e52ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element.  <br /></td></tr>
<tr class="separator:a49520dd5df3862084a2e4eb27f8e52ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b5feaa00eb499257a25bd92992a55a" id="r_ac2b5feaa00eb499257a25bd92992a55a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a">elements</a> (const char *name)</td></tr>
<tr class="memdesc:ac2b5feaa00eb499257a25bd92992a55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element with name <em>name</em>.  <br /></td></tr>
<tr class="separator:ac2b5feaa00eb499257a25bd92992a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04f0d0be3a2dcebbea37211cf787cd1" id="r_ad04f0d0be3a2dcebbea37211cf787cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ad04f0d0be3a2dcebbea37211cf787cd1">elements</a> (const char *name) const</td></tr>
<tr class="memdesc:ad04f0d0be3a2dcebbea37211cf787cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view of child nodes of type type_element with name <em>name</em>.  <br /></td></tr>
<tr class="separator:ad04f0d0be3a2dcebbea37211cf787cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade044c2b31477ea673e9839b3fb7cfcf" id="r_ade044c2b31477ea673e9839b3fb7cfcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ade044c2b31477ea673e9839b3fb7cfcf">insert</a> (const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:ade044c2b31477ea673e9839b3fb7cfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node.  <br /></td></tr>
<tr class="separator:ade044c2b31477ea673e9839b3fb7cfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16013c5b1e30dff7613dd0be487379a2" id="r_a16013c5b1e30dff7613dd0be487379a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a16013c5b1e30dff7613dd0be487379a2">insert</a> (const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;position, const <a class="el" href="classxml_1_1node.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a16013c5b1e30dff7613dd0be487379a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new child node.  <br /></td></tr>
<tr class="separator:a16013c5b1e30dff7613dd0be487379a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f5714a2eae4aa9ec6846476bf78414" id="r_a08f5714a2eae4aa9ec6846476bf78414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a08f5714a2eae4aa9ec6846476bf78414">replace</a> (const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;old_node, const <a class="el" href="classxml_1_1node.html">node</a> &amp;new_node)</td></tr>
<tr class="memdesc:a08f5714a2eae4aa9ec6846476bf78414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the node pointed to by the given iterator with another node.  <br /></td></tr>
<tr class="separator:a08f5714a2eae4aa9ec6846476bf78414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37a72ed93f838c58057c3865d21ff4f" id="r_af37a72ed93f838c58057c3865d21ff4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af37a72ed93f838c58057c3865d21ff4f">erase</a> (const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;to_erase)</td></tr>
<tr class="memdesc:af37a72ed93f838c58057c3865d21ff4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the node that is pointed to by the given iterator.  <br /></td></tr>
<tr class="separator:af37a72ed93f838c58057c3865d21ff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b022990103fc1c806f5602cf7dbf58e" id="r_a6b022990103fc1c806f5602cf7dbf58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a6b022990103fc1c806f5602cf7dbf58e">erase</a> (<a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> first, const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;last)</td></tr>
<tr class="memdesc:a6b022990103fc1c806f5602cf7dbf58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all nodes in the given range, from first to last.  <br /></td></tr>
<tr class="separator:a6b022990103fc1c806f5602cf7dbf58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c78e6293283e648e11da94b6a9754" id="r_ab75c78e6293283e648e11da94b6a9754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxml_1_1node.html#ae59270c9d507c08b8b4c5df88ac12913">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#ab75c78e6293283e648e11da94b6a9754">erase</a> (const char *name)</td></tr>
<tr class="memdesc:ab75c78e6293283e648e11da94b6a9754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all children nodes with the given name.  <br /></td></tr>
<tr class="separator:ab75c78e6293283e648e11da94b6a9754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b337ebcc316777526b8010eec985e9f" id="r_a1b337ebcc316777526b8010eec985e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a1b337ebcc316777526b8010eec985e9f">clear</a> ()</td></tr>
<tr class="memdesc:a1b337ebcc316777526b8010eec985e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all children nodes.  <br /></td></tr>
<tr class="separator:a1b337ebcc316777526b8010eec985e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af224e8f7ccc7da323855a81018e23cab" id="r_af224e8f7ccc7da323855a81018e23cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#af224e8f7ccc7da323855a81018e23cab">sort</a> (const char *node_name, const char *attr_name)</td></tr>
<tr class="memdesc:af224e8f7ccc7da323855a81018e23cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all the children nodes of this node using one of their attributes.  <br /></td></tr>
<tr class="separator:af224e8f7ccc7da323855a81018e23cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11efe78e773372416c9e1b641394ced6" id="r_a11efe78e773372416c9e1b641394ced6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11efe78e773372416c9e1b641394ced6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a11efe78e773372416c9e1b641394ced6">sort</a> (T compare)</td></tr>
<tr class="memdesc:a11efe78e773372416c9e1b641394ced6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort all the children nodes of this node using the given comparison function object.  <br /></td></tr>
<tr class="separator:a11efe78e773372416c9e1b641394ced6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6a922582c1a85cd886a694e2ca6c8f" id="r_a3f6a922582c1a85cd886a694e2ca6c8f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#a3f6a922582c1a85cd886a694e2ca6c8f">node_to_string</a> () const</td></tr>
<tr class="memdesc:a3f6a922582c1a85cd886a694e2ca6c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the node and all its children into XML text and return the string containing them.  <br /></td></tr>
<tr class="separator:a3f6a922582c1a85cd886a694e2ca6c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa465b31a3a9180162a0ec87161c3e51b" id="r_aa465b31a3a9180162a0ec87161c3e51b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxml_1_1node.html#aa465b31a3a9180162a0ec87161c3e51b">node_to_string</a> (std::string &amp;xml) const</td></tr>
<tr class="memdesc:aa465b31a3a9180162a0ec87161c3e51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the node and all its children into XML text and set the given string to that text.  <br /></td></tr>
<tr class="separator:aa465b31a3a9180162a0ec87161c3e51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> class is used to hold information about one XML node. </p>
<p>This includes the name of the node, the namespace of the node and attributes for the node. It also has an iterator whereby you can get to the children nodes.</p>
<p>It should be noted that any member function that returns a const char* returns a temporary value. The pointer that is returned will change with ANY operation to the <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. If you need the data to stick around a little longer you should put it inside a std::string. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae59270c9d507c08b8b4c5df88ac12913" name="ae59270c9d507c08b8b4c5df88ac12913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59270c9d507c08b8b4c5df88ac12913">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxml_1_1node.html#ae59270c9d507c08b8b4c5df88ac12913">xml::node::size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a940647610d4ab69275a4889886b3cc73" name="a940647610d4ab69275a4889886b3cc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940647610d4ab69275a4889886b3cc73">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">xml::node::node_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enum for the different types of XML nodes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442" name="a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442"></a>type_element&#160;</td><td class="fielddoc"><p>XML element such as "&lt;chapter/&gt;". </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73ad3894a3c892717b03c8835774bade863" name="a940647610d4ab69275a4889886b3cc73ad3894a3c892717b03c8835774bade863"></a>type_text&#160;</td><td class="fielddoc"><p>Text node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73ad08a3d7542cb53715b7eb9fe61afc43a" name="a940647610d4ab69275a4889886b3cc73ad08a3d7542cb53715b7eb9fe61afc43a"></a>type_cdata&#160;</td><td class="fielddoc"><p>text </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73af9787bf54e2a8186b643aaabf94850ad" name="a940647610d4ab69275a4889886b3cc73af9787bf54e2a8186b643aaabf94850ad"></a>type_pi&#160;</td><td class="fielddoc"><p>Processing Instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73aba376b6f894af123d9b0d2d3e9a87754" name="a940647610d4ab69275a4889886b3cc73aba376b6f894af123d9b0d2d3e9a87754"></a>type_comment&#160;</td><td class="fielddoc"><p>XML comment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73aeaad8ffd4e23a12dc244b10502c3630a" name="a940647610d4ab69275a4889886b3cc73aeaad8ffd4e23a12dc244b10502c3630a"></a>type_entity&#160;</td><td class="fielddoc"><p>Entity as in &amp;amp;. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73af09519f20be672ab7271f9588cb1f141" name="a940647610d4ab69275a4889886b3cc73af09519f20be672ab7271f9588cb1f141"></a>type_entity_ref&#160;</td><td class="fielddoc"><p>Entity ref. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a47e2014a31a4e8d5ce5b65610be5785a" name="a940647610d4ab69275a4889886b3cc73a47e2014a31a4e8d5ce5b65610be5785a"></a>type_xinclude&#160;</td><td class="fielddoc"><p>&lt;xi:include/&gt; node </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a90fb6fc3b406e9eabc666307a2182505" name="a940647610d4ab69275a4889886b3cc73a90fb6fc3b406e9eabc666307a2182505"></a>type_document&#160;</td><td class="fielddoc"><p>Document node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a5ad2575daf153e4c9342098834e800b1" name="a940647610d4ab69275a4889886b3cc73a5ad2575daf153e4c9342098834e800b1"></a>type_document_type&#160;</td><td class="fielddoc"><p>DOCTYPE node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a510868f4ada4c9e121907f2926253dc9" name="a940647610d4ab69275a4889886b3cc73a510868f4ada4c9e121907f2926253dc9"></a>type_document_frag&#160;</td><td class="fielddoc"><p>Document Fragment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a4b4ec4e4ae3cd25413af91024e3d5c7d" name="a940647610d4ab69275a4889886b3cc73a4b4ec4e4ae3cd25413af91024e3d5c7d"></a>type_notation&#160;</td><td class="fielddoc"><p>Notation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73ad067513260fc3cba8adb7e4046fa522f" name="a940647610d4ab69275a4889886b3cc73ad067513260fc3cba8adb7e4046fa522f"></a>type_dtd&#160;</td><td class="fielddoc"><p>DTD node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a71a97e98535c1961a23a781758921fec" name="a940647610d4ab69275a4889886b3cc73a71a97e98535c1961a23a781758921fec"></a>type_dtd_element&#160;</td><td class="fielddoc"><p>DTD &lt;!ELEMENT&gt; node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73affbc2f67724bd953ca2cc4fb5f788668" name="a940647610d4ab69275a4889886b3cc73affbc2f67724bd953ca2cc4fb5f788668"></a>type_dtd_attribute&#160;</td><td class="fielddoc"><p>DTD &lt;!ATTRLIST&gt; node. </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73acd5165d4b1015313b836696388511e04" name="a940647610d4ab69275a4889886b3cc73acd5165d4b1015313b836696388511e04"></a>type_dtd_entity&#160;</td><td class="fielddoc"><p>DTD &lt;!ENTITY&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a940647610d4ab69275a4889886b3cc73a22cffeab9645fd51d6341a7e6ef8de91" name="a940647610d4ab69275a4889886b3cc73a22cffeab9645fd51d6341a7e6ef8de91"></a>type_dtd_namespace&#160;</td><td class="fielddoc"><p>? </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a36262413721060030db06031e6932233" name="a36262413721060030db06031e6932233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36262413721060030db06031e6932233">&#9670;&#160;</a></span>node() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new blank <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. </p>

</div>
</div>
<a id="a53e68e8305a47f686b22a2b39f60c5cb" name="a53e68e8305a47f686b22a2b39f60c5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e68e8305a47f686b22a2b39f60c5cb">&#9670;&#160;</a></span>node() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> and set the name of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cfe3254a9552e9d398053c67bea42de" name="a5cfe3254a9552e9d398053c67bea42de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfe3254a9552e9d398053c67bea42de">&#9670;&#160;</a></span>node() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> given a name and content. </p>
<p>The content, if it's not an empty string, will be used to create a new child text node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the new element. </td></tr>
    <tr><td class="paramname">content</td><td>The text that will be used to create a child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addc8f567fa1ec7ced116ed4fc2cd0c4d" name="addc8f567fa1ec7ced116ed4fc2cd0c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc8f567fa1ec7ced116ed4fc2cd0c4d">&#9670;&#160;</a></span>node() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1cdata.html">cdata</a>&#160;</td>
          <td class="paramname"><em>cdata_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_cdata. </p>
<p>The cdata_info parameter should contain the contents of the CDATA section.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code hl_class" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code hl_struct" href="structxml_1_1node_1_1cdata.html">xml::node::cdata</a>(<span class="stringliteral">&quot;This is a CDATA section&quot;</span>));</div>
<div class="ttc" id="aclassxml_1_1node_html"><div class="ttname"><a href="classxml_1_1node.html">xml::node</a></div><div class="ttdoc">The xml::node class is used to hold information about one XML node.</div><div class="ttdef"><b>Definition</b> node.h:92</div></div>
<div class="ttc" id="astructxml_1_1node_1_1cdata_html"><div class="ttname"><a href="structxml_1_1node_1_1cdata.html">xml::node::cdata</a></div><div class="ttdoc">Helper struct for creating a xml::node of type_cdata.</div><div class="ttdef"><b>Definition</b> node.h:127</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cdata_info</td><td>A cdata struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> what the content will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac5cf010b25c9f0ea2415ae99c6610bc" name="aac5cf010b25c9f0ea2415ae99c6610bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5cf010b25c9f0ea2415ae99c6610bc">&#9670;&#160;</a></span>node() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1comment.html">comment</a>&#160;</td>
          <td class="paramname"><em>comment_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_comment. </p>
<p>The comment_info parameter should contain the contents of the XML comment.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code hl_class" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code hl_struct" href="structxml_1_1node_1_1comment.html">xml::node::comment</a>(<span class="stringliteral">&quot;This is an XML comment&quot;</span>));</div>
<div class="ttc" id="astructxml_1_1node_1_1comment_html"><div class="ttname"><a href="structxml_1_1node_1_1comment.html">xml::node::comment</a></div><div class="ttdoc">Helper struct for creating a xml::node of type_comment.</div><div class="ttdef"><b>Definition</b> node.h:140</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment_info</td><td>A comment struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> what the comment will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1a164e7c81012e4a721531c34d6ba5" name="aad1a164e7c81012e4a721531c34d6ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1a164e7c81012e4a721531c34d6ba5">&#9670;&#160;</a></span>node() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1pi.html">pi</a>&#160;</td>
          <td class="paramname"><em>pi_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_pi. </p>
<p>The pi_info parameter should contain the name of the XML processing instruction (PI), and optionally, the contents of the XML PI.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code hl_class" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code hl_struct" href="structxml_1_1node_1_1pi.html">xml::node::pi</a>(<span class="stringliteral">&quot;xslt&quot;</span>, <span class="stringliteral">&quot;stylesheet=\&quot;test.xsl\&quot;&quot;</span>));</div>
<div class="ttc" id="astructxml_1_1node_1_1pi_html"><div class="ttname"><a href="structxml_1_1node_1_1pi.html">xml::node::pi</a></div><div class="ttdoc">Helper struct for creating a xml::node of type_pi.</div><div class="ttdef"><b>Definition</b> node.h:153</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pi_info</td><td>A pi struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> what the name and contents of the XML PI are. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf2aa7ee2a4fee030e7c9bb0f64db859" name="aaf2aa7ee2a4fee030e7c9bb0f64db859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2aa7ee2a4fee030e7c9bb0f64db859">&#9670;&#160;</a></span>node() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxml_1_1node_1_1text.html">text</a>&#160;</td>
          <td class="paramname"><em>text_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> that is of type_text. </p>
<p>The text_info parameter should contain the text.</p>
<dl class="section note"><dt>Note</dt><dd>Sample Use Example: <div class="fragment"><div class="line"><a class="code hl_class" href="classxml_1_1node.html">xml::node</a> mynode(<a class="code hl_struct" href="structxml_1_1node_1_1text.html">xml::node::text</a>(<span class="stringliteral">&quot;This is XML text&quot;</span>));</div>
<div class="ttc" id="astructxml_1_1node_1_1text_html"><div class="ttname"><a href="structxml_1_1node_1_1text.html">xml::node::text</a></div><div class="ttdoc">Helper struct for creating a xml::node of type_text.</div><div class="ttdef"><b>Definition</b> node.h:167</div></div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text_info</td><td>A text struct that tells <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> what the text will be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a362154201ae3c6aa4213d4c8319e05" name="a7a362154201ae3c6aa4213d4c8319e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a362154201ae3c6aa4213d4c8319e05">&#9670;&#160;</a></span>node() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> by copying another <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other node to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6cfd0d55c969e9407d09b56fe6d4fd9" name="ae6cfd0d55c969e9407d09b56fe6d4fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cfd0d55c969e9407d09b56fe6d4fd9">&#9670;&#160;</a></span>~node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml::node::~node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a19f2858db5fed987227f80ff1c556b0b" name="a19f2858db5fed987227f80ff1c556b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f2858db5fed987227f80ff1c556b0b">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points to the beginning of this node's children. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the beginning of the children. </dd></dl>

</div>
</div>
<a id="aacd0fff05e288b7b08d52df1c28be17b" name="aacd0fff05e288b7b08d52df1c28be17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd0fff05e288b7b08d52df1c28be17b">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the beginning of this node's children. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the beginning of the children. </dd></dl>

</div>
</div>
<a id="a1b337ebcc316777526b8010eec985e9f" name="a1b337ebcc316777526b8010eec985e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b337ebcc316777526b8010eec985e9f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all children nodes. </p>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a id="aa04c038a0f3fa58c3ed8069f8fe7a3a4" name="aa04c038a0f3fa58c3ed8069f8fe7a3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04c038a0f3fa58c3ed8069f8fe7a3a4">&#9670;&#160;</a></span>elements() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : root.<a class="code hl_function" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a>())</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassxml_1_1node_html_aa04c038a0f3fa58c3ed8069f8fe7a3a4"><div class="ttname"><a href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">xml::node::elements</a></div><div class="ttdeci">nodes_view elements()</div><div class="ttdoc">Returns view of child nodes of type type_element.</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>View with all child elements or empty view if there aren't any. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1nodes__view.html" title="This class implements a view of XML nodes.">nodes_view</a> </dd></dl>

</div>
</div>
<a id="a49520dd5df3862084a2e4eb27f8e52ca" name="a49520dd5df3862084a2e4eb27f8e52ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49520dd5df3862084a2e4eb27f8e52ca">&#9670;&#160;</a></span>elements() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classxml_1_1const__nodes__view.html">xml::const_nodes_view</a> view(root.elements());</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : root.<a class="code hl_function" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a>())</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassxml_1_1const__nodes__view_html"><div class="ttname"><a href="classxml_1_1const__nodes__view.html">xml::const_nodes_view</a></div><div class="ttdoc">This class implements a read-only view of XML nodes.</div><div class="ttdef"><b>Definition</b> nodes_view.h:256</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>View with all child elements or empty view if there aren't any. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1const__nodes__view.html" title="This class implements a read-only view of XML nodes.">const_nodes_view</a> </dd></dl>

</div>
</div>
<a id="ac2b5feaa00eb499257a25bd92992a55a" name="ac2b5feaa00eb499257a25bd92992a55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b5feaa00eb499257a25bd92992a55a">&#9670;&#160;</a></span>elements() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1nodes__view.html">nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element with name <em>name</em>. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : root.<a class="code hl_function" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a>(<span class="stringliteral">&quot;person&quot;</span>))</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the elements to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>View that contains only elements <em>name</em>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

</div>
</div>
<a id="ad04f0d0be3a2dcebbea37211cf787cd1" name="ad04f0d0be3a2dcebbea37211cf787cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04f0d0be3a2dcebbea37211cf787cd1">&#9670;&#160;</a></span>elements() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1const__nodes__view.html">const_nodes_view</a> xml::node::elements </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns view of child nodes of type type_element with name <em>name</em>. </p>
<p>If no such node can be found, returns empty view.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem : root.<a class="code hl_function" href="classxml_1_1node.html#aa04c038a0f3fa58c3ed8069f8fe7a3a4">elements</a>(<span class="stringliteral">&quot;person&quot;</span>))</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the elements to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>View that contains only elements <em>name</em>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

</div>
</div>
<a id="a50dec73910f4edd024421a8949caa7d7" name="a50dec73910f4edd024421a8949caa7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dec73910f4edd024421a8949caa7d7">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::node::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if this node has any children. </p>
<p>This is the same as <a class="el" href="classxml_1_1node.html#a3c837d33ae3431285c899cadb4071561" title="Returns the number of children this nodes has.">xml::node::size()</a> == 0 except it is much faster.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this node DOES NOT have any children. </dd>
<dd>
False if this node does have children. </dd></dl>

</div>
</div>
<a id="a92d53ce343ec4ef8678d18cf6c0b4552" name="a92d53ce343ec4ef8678d18cf6c0b4552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d53ce343ec4ef8678d18cf6c0b4552">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator that points one past the last child for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A "one past the end" iterator. </dd></dl>

</div>
</div>
<a id="a9e7ba735bf213ee58dd287c766ef7309" name="a9e7ba735bf213ee58dd287c766ef7309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7ba735bf213ee58dd287c766ef7309">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points one past the last child for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A "one past the end" <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> </dd></dl>

</div>
</div>
<a id="ab75c78e6293283e648e11da94b6a9754" name="ab75c78e6293283e648e11da94b6a9754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75c78e6293283e648e11da94b6a9754">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html#ae59270c9d507c08b8b4c5df88ac12913">size_type</a> xml::node::erase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all children nodes with the given name. </p>
<p>This will find all nodes that have the given node name and remove them from this node. This will invalidate any iterators that point to the nodes to be erased, or any pointers or references to those nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of nodes to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes removed. </dd></dl>

</div>
</div>
<a id="af37a72ed93f838c58057c3865d21ff4f" name="af37a72ed93f838c58057c3865d21ff4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37a72ed93f838c58057c3865d21ff4f">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>to_erase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the node that is pointed to by the given iterator. </p>
<p>The node and all its children will be removed from this node. This will invalidate any iterators that point to the node to be erased, or any pointers or references to that node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_erase</td><td>An iterator that points to the node to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node after the one being erased. </dd></dl>

</div>
</div>
<a id="a6b022990103fc1c806f5602cf7dbf58e" name="a6b022990103fc1c806f5602cf7dbf58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b022990103fc1c806f5602cf7dbf58e">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase all nodes in the given range, from first to last. </p>
<p>This will invalidate any iterators that point to the nodes to be erased, or any pointers or references to those nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first node in the range to be removed. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator that points one past the last node to erase. Think <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">xml::node::end()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node after the last one being erased. </dd></dl>

</div>
</div>
<a id="a9c0e38e5095f0e682e00ea47d5d90a30" name="a9c0e38e5095f0e682e00ea47d5d90a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0e38e5095f0e682e00ea47d5d90a30">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node that has the given name. </p>
<p>If no such node can be found, this function will return the same iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> would return.</p>
<p>This function is not recursive. That is, it will not search down the tree for the requested node. Instead, it will only search one level deep, only checking the children of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> iterator if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a" title="Returns view of child nodes of type type_element with name name.">elements(const char*)</a>, find(const char*, iterator) </dd></dl>

</div>
</div>
<a id="a2f8925ba89a935a3f120fdb02acd6bb4" name="a2f8925ba89a935a3f120fdb02acd6bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8925ba89a935a3f120fdb02acd6bb4">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node that has the given name. </p>
<p>If no such node can be found, this function will return the same <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> would return.</p>
<p>This function is not recursive. That is, it will not search down the tree for the requested node. Instead, it will only search one level deep, only checking the children of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ad04f0d0be3a2dcebbea37211cf787cd1" title="Returns view of child nodes of type type_element with name name.">elements(const char*) const</a>, find(const char*, const_iterator) const </dd></dl>

</div>
</div>
<a id="afc577bd97012580407428e5f90a3b1fd" name="afc577bd97012580407428e5f90a3b1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc577bd97012580407428e5f90a3b1fd">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node, starting with the given <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a>, that has the given name. </p>
<p>If no such node can be found, this function will return the same <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> would return.</p>
<p>This function should be given a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> to one of this node's children. The search will begin with that node and continue with all its siblings. This function will not recurse down the tree, it only searches in one level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
    <tr><td class="paramname">start</td><td>Where to begin the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ad04f0d0be3a2dcebbea37211cf787cd1" title="Returns view of child nodes of type type_element with name name.">elements(const char*) const</a> </dd></dl>

</div>
</div>
<a id="aac2bc3080530e7f48812a73907288ac0" name="aac2bc3080530e7f48812a73907288ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2bc3080530e7f48812a73907288ac0">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first child node, starting with the given iterator, that has the given name. </p>
<p>If no such node can be found, this function will return the same iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> would return.</p>
<p>This function should be given an iterator to one of this node's children. The search will begin with that node and continue with all its sibliings. This function will not recurse down the tree, it only searches in one level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node you want to find. </td></tr>
    <tr><td class="paramname">start</td><td>Where to begin the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the node if found. </dd>
<dd>
An <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">end()</a> iterator if the node was not found.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ac2b5feaa00eb499257a25bd92992a55a" title="Returns view of child nodes of type type_element with name name.">elements(const char*)</a> </dd></dl>

</div>
</div>
<a id="ab4eb6292a54814e9d50283964c80454c" name="ab4eb6292a54814e9d50283964c80454c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb6292a54814e9d50283964c80454c">&#9670;&#160;</a></span>get_attributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1attributes.html">xml::attributes</a> &amp; xml::node::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of attributes. </p>
<p>You can use the returned object to get and set the attributes for this node. Make sure you use a reference to this returned object, to prevent a copy.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node.">xml::attributes</a> object for this node. </dd></dl>

</div>
</div>
<a id="ab3840b65141aad8d17eebc094ee76c03" name="ab3840b65141aad8d17eebc094ee76c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3840b65141aad8d17eebc094ee76c03">&#9670;&#160;</a></span>get_attributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxml_1_1attributes.html">xml::attributes</a> &amp; xml::node::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of attributes. </p>
<p>You can use the returned object to get the attributes for this node. Make sure you use a reference to this returned object, to prevent a copy.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classxml_1_1attributes.html" title="The xml::attributes class is used to access all the attributes of one xml::node.">xml::attributes</a> object for this node. </dd></dl>

</div>
</div>
<a id="a2a99a22514f5563704fc2081f0b72d34" name="a2a99a22514f5563704fc2081f0b72d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a99a22514f5563704fc2081f0b72d34">&#9670;&#160;</a></span>get_content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xml::node::get_content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the content for this text node. </p>
<p>If this node is not a text node but it has children nodes that are text nodes, the contents of those child nodes will be returned. If there is no content or these conditions do not apply, zero will be returned.</p>
<p>This function may change in the future to return std::string. Feedback is welcome.</p>
<dl class="section return"><dt>Returns</dt><dd>The content or 0. </dd></dl>

</div>
</div>
<a id="af0bd5408b66cd2d7a0d87aae6c03a821" name="af0bd5408b66cd2d7a0d87aae6c03a821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bd5408b66cd2d7a0d87aae6c03a821">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xml::node::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. </p>
<p>This function may change in the future to return std::string. Feedback is welcome.</p>
<dl class="section return"><dt>Returns</dt><dd>The name of this node. </dd></dl>

</div>
</div>
<a id="a9e3f8338528b5f55032d91eab5dd1db4" name="a9e3f8338528b5f55032d91eab5dd1db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3f8338528b5f55032d91eab5dd1db4">&#9670;&#160;</a></span>get_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xml::node::get_namespace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The namespace of this node or nullptr if no namespace is associated. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.6.0 </dd></dl>

</div>
</div>
<a id="a6a52b1707c415f5ea488cffca48a03dd" name="a6a52b1707c415f5ea488cffca48a03dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a52b1707c415f5ea488cffca48a03dd">&#9670;&#160;</a></span>get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73">node_type</a> xml::node::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get this node's "type". </p>
<p>You can use that information to know what you can and cannot do with it.</p>
<dl class="section return"><dt>Returns</dt><dd>The node's type. </dd></dl>

</div>
</div>
<a id="a16013c5b1e30dff7613dd0be487379a2" name="a16013c5b1e30dff7613dd0be487379a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16013c5b1e30dff7613dd0be487379a2">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node. </p>
<p>The new node will be inserted before the node pointed to by the given iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>An iterator that points to the location where the new node should be inserted (before it). </td></tr>
    <tr><td class="paramname">n</td><td>The node to insert as a child of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted node. </dd></dl>

</div>
</div>
<a id="ade044c2b31477ea673e9839b3fb7cfcf" name="ade044c2b31477ea673e9839b3fb7cfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade044c2b31477ea673e9839b3fb7cfcf">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new child node. </p>
<p>The new node will be inserted at the end of the child list. This is similar to the <a class="el" href="classxml_1_1node.html#a78a5f8a31988380cf45fab6eaff3327c" title="Add a child xml::node to this node.">xml::node::push_back</a> member function except that an iterator to the inserted node is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node to insert as a child of this node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted node. </dd></dl>

</div>
</div>
<a id="aa7ab51a6c1607946e734021399e13da6" name="aa7ab51a6c1607946e734021399e13da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ab51a6c1607946e734021399e13da6">&#9670;&#160;</a></span>is_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xml::node::is_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out if this node is a text node or something like a text node, CDATA for example. </p>
<dl class="section return"><dt>Returns</dt><dd>True if this node is a text node; false otherwise. </dd></dl>

</div>
</div>
<a id="ae944b8c4c154a91ad3e539776f05585a" name="ae944b8c4c154a91ad3e539776f05585a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae944b8c4c154a91ad3e539776f05585a">&#9670;&#160;</a></span>move_under()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::move_under </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>new_parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move this node under another parent. </p>
<p>This node will become the last child of <em>new_parent</em>. Notice that this node must not be an ancestor of <em>new_parent</em>, in particular it shouldn't be the document root.</p>
<p>Currently this method can only be used to move nodes inside the same document.</p>
<p>All iterators pointing to this node are invalidated after the move.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_parent</td><td>The new parent for the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>

</div>
</div>
<a id="a3f6a922582c1a85cd886a694e2ca6c8f" name="a3f6a922582c1a85cd886a694e2ca6c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6a922582c1a85cd886a694e2ca6c8f">&#9670;&#160;</a></span>node_to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xml::node::node_to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the node and all its children into XML text and return the string containing them. </p>
<dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>

</div>
</div>
<a id="aa465b31a3a9180162a0ec87161c3e51b" name="aa465b31a3a9180162a0ec87161c3e51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa465b31a3a9180162a0ec87161c3e51b">&#9670;&#160;</a></span>node_to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::node_to_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the node and all its children into XML text and set the given string to that text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml</td><td>The string to set the node's XML data to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38fa69c582c0c5d2fc067644d608bd24" name="a38fa69c582c0c5d2fc067644d608bd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fa69c582c0c5d2fc067644d608bd24">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html">node</a> &amp; xml::node::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make this node equal to some other node via assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other node to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this node. </dd></dl>

</div>
</div>
<a id="aa8a56ed0ea190af87784ea4869525ec8" name="aa8a56ed0ea190af87784ea4869525ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a56ed0ea190af87784ea4869525ec8">&#9670;&#160;</a></span>parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points at the parent of this node. </p>
<p>If this node does not have a parent, this member function will return an "end" iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to this nodes parent. </dd>
<dd>
If no parent, returns the same iterator that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">xml::node::end()</a> returns. </dd></dl>

</div>
</div>
<a id="a28d14bdf1fd828cfa6ca481f2b3afd57" name="a28d14bdf1fd828cfa6ca481f2b3afd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d14bdf1fd828cfa6ca481f2b3afd57">&#9670;&#160;</a></span>parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points at the parent of this node. </p>
<p>If this node does not have a parent, this member function will return an "end" <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points to this nodes parent. </dd>
<dd>
If no parent, returns the same <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that <a class="el" href="classxml_1_1node.html#a92d53ce343ec4ef8678d18cf6c0b4552" title="Get an iterator that points one past the last child for this node.">xml::node::end()</a> returns. </dd></dl>

</div>
</div>
<a id="a78a5f8a31988380cf45fab6eaff3327c" name="a78a5f8a31988380cf45fab6eaff3327c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a5f8a31988380cf45fab6eaff3327c">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> to this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08f5714a2eae4aa9ec6846476bf78414" name="a08f5714a2eae4aa9ec6846476bf78414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f5714a2eae4aa9ec6846476bf78414">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>old_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the node pointed to by the given iterator with another node. </p>
<p>The old node will be removed, including all its children, and replaced with the new node. This will invalidate any iterators that point to the node to be replaced, or any pointers or references to that node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_node</td><td>An iterator that points to the node that should be removed. </td></tr>
    <tr><td class="paramname">new_node</td><td>The node to put in old_node's place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the new node. </dd></dl>

</div>
</div>
<a id="abd609b79b54671575478022b3cd76dca" name="abd609b79b54671575478022b3cd76dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd609b79b54671575478022b3cd76dca">&#9670;&#160;</a></span>self() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1iterator.html">iterator</a> xml::node::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator that points back at this node. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points at this node. </dd></dl>

</div>
</div>
<a id="a87f5320e1c6a84e13c7f5692f66b2ffd" name="a87f5320e1c6a84e13c7f5692f66b2ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f5320e1c6a84e13c7f5692f66b2ffd">&#9670;&#160;</a></span>self() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node_1_1const__iterator.html">const_iterator</a> xml::node::self </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points back at this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classxml_1_1node_1_1const__iterator.html" title="The xml::node::const_iterator provides a way to access children nodes similar to a standard C++ conta...">const_iterator</a> that points at this node. </dd></dl>

</div>
</div>
<a id="ab4625509cfbe6bf475f751d51ff6f10a" name="ab4625509cfbe6bf475f751d51ff6f10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4625509cfbe6bf475f751d51ff6f10a">&#9670;&#160;</a></span>set_content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_content </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the content of a node. </p>
<p>If this node is an element node, this function will remove all of its children nodes and replace them with one text node set to the given string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content of the text node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>content</em> is supposed to be a piece of XML CDATA, so it allows entity references, but XML special chars need to be escaped first. In particular, the '&amp;' character <em>must</em> be escaped as "&amp;amp;" unless it's part of entity reference. Not escaping <em>content</em> may result in truncation of data. Use <a class="el" href="classxml_1_1node.html#af7e81da5ef8eed970e974d1945c4d830" title="Set the content of a node to given text.">set_text_content()</a> if <em>content</em> may contain special characters.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#af7e81da5ef8eed970e974d1945c4d830" title="Set the content of a node to given text.">set_text_content()</a> </dd></dl>

</div>
</div>
<a id="a02d75545214dba0cf6d7efeb5ecfa2bc" name="a02d75545214dba0cf6d7efeb5ecfa2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d75545214dba0cf6d7efeb5ecfa2bc">&#9670;&#160;</a></span>set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name for this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab847851d49148c231bd6630ee1b7e9b3" name="ab847851d49148c231bd6630ee1b7e9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab847851d49148c231bd6630ee1b7e9b3">&#9670;&#160;</a></span>set_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_namespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>href</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the namespace of this <a class="el" href="classxml_1_1node.html" title="The xml::node class is used to hold information about one XML node.">xml::node</a> and its children. </p>
<p>Calling this function also affects the namespace of the children of this node, if any: all children that previously used the same namespace as this node are updated to use the new namespace. This includes the case when this node didn't previously have any namespace, but note that in this particular case, when a new namespace is being set, this function needs to update all children and so can be relatively time-consuming for large trees, while changing an existing namespace is done in constant time.</p>
<p>If the default namespace is already set on this node, it is changed.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// n is &lt;foo/&gt;</span></div>
<div class="line">n.set_namespace(<span class="stringliteral">&quot;http://example.com&quot;</span>)</div>
<div class="line"><span class="comment">// n is &lt;foo xmlns=&quot;http://example.com&quot;/&gt;</span></div>
</div><!-- fragment --><dl class="section since"><dt>Since</dt><dd>0.8.0 </dd></dl>

</div>
</div>
<a id="af7e81da5ef8eed970e974d1945c4d830" name="af7e81da5ef8eed970e974d1945c4d830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e81da5ef8eed970e974d1945c4d830">&#9670;&#160;</a></span>set_text_content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::set_text_content </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the content of a node to given text. </p>
<p>In contrast to <a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a" title="Set the content of a node.">set_content()</a>, <em>content</em> is raw text, so unescaped XML special chars are allowed and entity references are not supported.</p>
<p>If this node is an element node, this function will remove all of its children nodes and replace them with one text node set to the given string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The content text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxml_1_1node.html#ab4625509cfbe6bf475f751d51ff6f10a" title="Set the content of a node.">set_content()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.7.0 </dd></dl>

</div>
</div>
<a id="a3c837d33ae3431285c899cadb4071561" name="a3c837d33ae3431285c899cadb4071561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c837d33ae3431285c899cadb4071561">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxml_1_1node.html#ae59270c9d507c08b8b4c5df88ac12913">size_type</a> xml::node::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of children this nodes has. </p>
<p>If you just want to know how if this node has children or not, you should use <a class="el" href="classxml_1_1node.html#a50dec73910f4edd024421a8949caa7d7" title="Find out if this node has any children.">xml::node::empty()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of children this node has. </dd></dl>

</div>
</div>
<a id="af224e8f7ccc7da323855a81018e23cab" name="af224e8f7ccc7da323855a81018e23cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af224e8f7ccc7da323855a81018e23cab">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::sort </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>node_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attr_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort all the children nodes of this node using one of their attributes. </p>
<p>Only nodes that are of <a class="el" href="classxml_1_1node.html#a940647610d4ab69275a4889886b3cc73a2267a73c5f21eff1f49d11d596f4e442" title="XML element such as &quot;&lt;chapter/&gt;&quot;.">xml::node::type_element</a> will be sorted, and they must have the given node_name.</p>
<p>The sorting is done by calling std::strcmp on the value of the given attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_name</td><td>The name of the nodes to sort. </td></tr>
    <tr><td class="paramname">attr_name</td><td>The attribute to sort on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11efe78e773372416c9e1b641394ced6" name="a11efe78e773372416c9e1b641394ced6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11efe78e773372416c9e1b641394ced6">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::sort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort all the children nodes of this node using the given comparison function object. </p>
<p>All element type nodes will be considered for sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>The binary function object to call in order to sort all child nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade0eccee02bde40ac06bcd632cc5ad38" name="ade0eccee02bde40ac06bcd632cc5ad38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0eccee02bde40ac06bcd632cc5ad38">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xml::node::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxml_1_1node.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap this node with another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other node to swap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xmlwrapp/<a class="el" href="node_8h_source.html">node.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 5 2025 21:15:11 for xmlwrapp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
